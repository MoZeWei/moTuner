#include<string>
#include<vector>
#include<iostream>
#include<fstream>
#include "llvm/Pass.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/Module.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Support/FileSystem.h"
#include "llvm/IR/LegacyPassManager.h"
#include "llvm/Transforms/IPO/PassManagerBuilder.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IRReader/IRReader.h"
#include "llvm/Support/SourceMgr.h"
#include "llvm/Support/ToolOutputFile.h"
#include "llvm/Bitcode/BitcodeWriter.h"

/*
This code is to read a bitcode file generated by offload bundler
*/

using namespace llvm;

int main()
{
    LLVMContext context;
    SMDiagnostic error;
    std::unique_ptr<Module> M = parseIRFile(StringRef("/mnt/data/home/mzw/workspace/test_space/llvm_test/mark_test_hip.bc"),
                                                error, context);
    IRBuilder<> builder(M->getContext());

    std::string path = "/mnt/data/home/mzw/workspace/testspace/llvm_test/dimension.txt";

        //get the inserted function ptr
        //TO.DO.: Maybe we can use Module::getOrInsertFunction() to get function ptr;
        Function * output_dimension_func_ptr = M->getFunction("output_dimension_file");
        Function * output_CalledFuncID_func_ptr = M->getFunction("output_CalledFuncID_file");
        Value * arg_dimension_file_path = builder.CreateGlobalStringPtr(path);
        //Value * arg_CalledFuncID_file_path = builder.CreateGlobalStringPtr(FuncID_run_file_path);
        FunctionType * output_func_type = FunctionType::get(FunctionType::getVoidTy(M->getContext()),false);     //getVoidTy is a method in Class Type
        

        //SymbolTableList<Function> == FunctionListType
        for(Module::FunctionListType::iterator func = M->getFunctionList().begin(),
        end_Func = M->getFunctionList().end(); func != end_Func; func++)
        {
            //Function::iterator == BasicBlockListType::iterator
            errs()<<"Now we are facing declare of function "<<func->getName()<<"\n";
            for(Function::iterator bb = func->begin(); bb != func->end(); bb++)
            {
                for(BasicBlock::iterator inst = bb->begin(); inst != bb->end(); inst++)
                {
                    if(isa<CallInst>(inst))
                    {
                        //QUES.: What about InvokeInst which means indirect call?
                        Function * called_func = dyn_cast<CallInst>(inst)->getCalledFunction();
                        if(called_func && called_func->getName() == "GemmEx")
                        {
                            Value * arg_M = called_func->getOperand(3);
                            Value * arg_N = called_func->getOperand(4);
                            Value * arg_K = called_func->getOperand(5);

                            //Dont directly use errs() to print, use a print_func in self-made library(which can use errs() inside)
                            builder.SetInsertPoint(inst->getNextNode());
                            std::vector<Value*> args = {arg_M,arg_N,arg_K,arg_dimension_file_path};
                            CallInst * new_inst = builder.CreateCall(output_func_type,output_dimension_func_ptr,makeArrayRef(args));
                        }
                        else
                        {
                            errs()<<"This is not a call to function or a GemmEx function\n";
                        }
                    }
                }
            }
        }
    
        std::error_code ec;
        ToolOutputFile result("/mnt/data/home/mzw/workspace/test_space/llvm_test/new_mark_test_hip.bc", ec, sys::fs::F_None);
        WriteBitcodeToFile(*M, result.os());
        result.keep();

        return 0;

}


